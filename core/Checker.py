import copy
from fuzzywuzzy import fuzz
import re
from urllib.parse import unquote
from core.Config import xsschecker
from core.Requester import Requester
from core.Utils import replaceValue, fillHoles


def Checker(url, params, headers, GET, delay, payload, positions, timeout, encoding):
    checkString = 'st4r7s' + payload + '3nd'
    if encoding:
        checkString = encoding(unquote(checkString))
    try:
        response = Requester(url, replaceValue(
            params, xsschecker, checkString, copy.deepcopy), headers, GET, delay, timeout).text.lower()
    except IndexError:
        print('lol')
    reflectedPositions = []
    for match in re.finditer('st4r7s', response):
        reflectedPositions.append(match.start())
    if(reflectedPositions==[]):
        return [0 for i in range(len(positions))]
    filledPositions = fillHoles(positions, reflectedPositions)
    #  Itretating over the reflections
    num = 0 
    efficiencies = []
    for position in filledPositions:
        allEfficiencies = []
        try:
            reflected = response[reflectedPositions[num]
                :reflectedPositions[num]+len(checkString)]
            efficiency = fuzz.partial_ratio(reflected, checkString.lower())
            allEfficiencies.append(efficiency)
        except IndexError:
            pass
        if position:
            reflected = response[position:position+len(checkString)]
            #print(reflected)
            if encoding:
                checkString = encoding(checkString.lower())
            efficiency = fuzz.partial_ratio(reflected, checkString)
            #print(efficiency)
            if reflected[:-2] == ('\\%s' % checkString.replace('st4r7s', '').replace('3nd', '')):
                efficiency = 90
            allEfficiencies.append(efficiency)
            efficiencies.append(max(allEfficiencies))
        else:
            efficiencies.append(0)
        num += 1
    a=list(filter(None, efficiencies))
    temp=[]
    temp.extend(positions)
    temp.sort()
    c={}
    for x, y in zip(a, temp):c.update({y:x})
    a=[]
    for i in positions:
        a.append(c[i])
    return a
